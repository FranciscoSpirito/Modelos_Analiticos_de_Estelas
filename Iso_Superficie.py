import numpy as np
from scipy.interpolate import griddata, RectBivariateSpline

class Iso_Superficie(object):


    def __init__(self, X, Y, Z, U, V, W):
        """
        Compute a set of streamlines covering the given velocity field.
        X and Y - 1D or 2D (e.g. generated by np.meshgrid) arrays of the
                  grid points. The mesh spacing is assumed to be uniform
                  in each dimension.
        U and V - 2D arrays of the velocity field.
        """

        self.x = X
        self.y = Y
        self.z = Z
        self.u = U
        self.v = V
        self.w = W

    # Definimos una malla menos densa, rectangular y uniforme para un mejor manejo de los datos
    # npois: define la densidad de la grilla
    # meshXmin, meshXmax, meshYmin, meshYmax definen el dominio
    def redefinicion_de_grilla(self, npois, meshXmin, meshXmax, meshYmin, meshYmax):

        npoiX, npoiY = npois, npois

        xg = np.linspace(meshXmin, meshXmax, npoiX)
        yg = np.linspace(meshYmin, meshYmax, npoiY)

        XG, YG = np.meshgrid(xg, yg)

        # Interpolaci√≥n de variables output de OF sobre la grilla regular
        self.ZG = griddata((self.x, self.y), self.z, (XG, YG), method='linear')
        self.UG = griddata((self.x, self.y), self.u, (XG, YG), method='linear')
        self.VG = griddata((self.x, self.y), self.v, (XG, YG), method='linear')
        self.WG = griddata((self.x, self.y), self.w, (XG, YG), method='linear')

        # Definir interpoladores en base a la grilla regular
        self._interp_u = RectBivariateSpline(xg, yg, self.UG.T)  # Atention! transposition needed to make it work properly
        self._interp_v = RectBivariateSpline(xg, yg, self.VG.T)
        self._interp_w = RectBivariateSpline(xg, yg, self.WG.T)
        self._interp_z = RectBivariateSpline(xg, yg, self.ZG.T)


    def streamline_in_coord(self, coord_turbina):
        streamline = self._makeHalfStreamline(coord_turbina.x, coord_turbina.y, 1)
        return streamline


    def _interp(self, x, y):
        """ Compute the velocity at point (x,y) """

        u = self._interp_u(x, y)
        v = self._interp_v(x, y)

        return u, v


    def _makeHalfStreamline(self, x0, y0, sign):
        """
        Compute a streamline extending in one direction from the given point.
        """

        xmin = np.amin(self.x)
        xmax = np.amax(self.x)
        ymin = np.amin(self.y)
        ymax = np.amax(self.y)

        sx = []
        sy = []

        x = x0
        y = y0

        while xmin < x < xmax and ymin < y < ymax:

            u, v = self._interp(x, y)

            x += sign * (self.dr / np.sqrt(u**2 + v**2)) * u
            y += sign * (self.dr / np.sqrt(u**2 + v**2)) * v

            sx.append(x)
            sy.append(y)


        return sx, sy

    def longitud_streamline(self, x, y):
        # Calcula la longitud de una curva 3d
        z = self._interp_z(x, y)
        return np.sum(np.sqrt(np.sum(np.diff([x, y, z]) ** 2, axis=0)))

    def desplazamiento_vertical(self, x, y):
        # Calcula el dezplazamiento vertical de la ldc con el metodo del trapezio con la coordenada curvilinea s
        z = self._interp_z(x, y)
        s_i = np.cumsum(np.sqrt(np.sum(np.diff([x, y, z]) ** 2, axis=0)))
        s_i = np.insert(s_i, 0, 0)
        f_uvw = self._interp_w(x, y) / (self._interp_u(x, y) ** 2 + self._interp_v(x, y) ** 2)
        dz = np.trapz(f_uvw, x = s_i)
        return dz


