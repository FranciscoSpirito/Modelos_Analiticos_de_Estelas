import numpy as np
from scipy.interpolate import griddata, RectBivariateSpline

# Proyecto original: https://github.com/rougier/windmap

class Iso_Superficie(object):

    def __init__(self, X, Y, Z, U, V, W, npois):
        """
        Compute a set of streamlines covering the given velocity field.
        X and Y - 1D or 2D (e.g. generated by np.meshgrid) arrays of the
                  grid points. The mesh spacing is assumed to be uniform
                  in each dimension.
        U and V - 2D arrays of the velocity field.
        """

        # Definicion de densidad y limites de grilla
        npoiX, npoiY = npois, npois
        self.meshXmin, self.meshXmax = 1000, 5500
        self.meshYmin, self.meshYmax = 500, 5000
        self.xg = np.linspace(self.meshXmin, self.meshXmax, npoiX)
        self.yg = np.linspace(self.meshYmin, self.meshYmax, npoiY)
        self.XG, self.YG = np.meshgrid(self.xg, self.yg)

        # Interpolaci√≥n de variables output de OF sobre la grilla regular
        ZG = griddata((X, Y), Z, (self.XG, self.YG), method='linear')
        UG = griddata((X, Y), U, (self.XG, self.YG), method='linear')
        VG = griddata((X, Y), V, (self.XG, self.YG), method='linear')
        WG = griddata((X, Y), W, (self.XG, self.YG), method='linear')

        # Definir interpoladores en base a la grilla regular
        self._interp_u = RectBivariateSpline(self.xg, self.yg, UG.T)
        self._interp_v = RectBivariateSpline(self.xg, self.yg, VG.T)
        self._interp_w = RectBivariateSpline(self.xg, self.yg, WG.T)
        self._interp_z = RectBivariateSpline(self.xg, self.yg, ZG.T)


    # Genera un streamline desde el punto x0 y0 hacia adelante o atras
    def _makeHalfStreamline(self, x0, y0, xmin, xmax, ymin, ymax, dr, sign):
        """
        Compute a streamline extending in one direction from the given point.
        """

        sx = []
        sy = []
        ss = []
        sz = []

        x = x0
        y = y0
        s = 0.
        dz = 0.

        while xmin <= x <= xmax and ymin <= y <= ymax:
            u = self._interp_u(x, y).item()
            v = self._interp_v(x, y).item()
            w = self._interp_w(x, y).item()

            scale = sign * (dr / np.sqrt(u ** 2 + v ** 2))
            scale2 = sign * (dr / np.sqrt(u ** 2 + v ** 2 + w**2))

            x += scale * u
            y += scale * v
            # Here we may compute the actual s in 3D and also integrate the \Delta z
            dz += scale2 * w
            s += np.sqrt(dr ** 2 + (scale2 * w) ** 2)

            sx.append(x)
            sy.append(y)
            ss.append(s)
            sz.append(dz)

        return sx, sy, ss, sz


    def _makeStreamline(self, x0, y0, xmin, xmax, ymin, ymax, dr):
        """
        Compute a streamline extending in both directions from the given point.
        """

        sx, sy, ss, sz = self._makeHalfStreamline(x0, y0, xmin, xmax, ymin, ymax, dr, 1)  # forwards
        rx, ry, rs, rz = self._makeHalfStreamline(x0, y0, xmin, xmax, ymin, ymax, dr, -1)  # backwards

        rx.reverse()
        ry.reverse()
        rs.reverse()
        rz.reverse()

        # Busqueda de Semilla para corregir desplazamiento en z, buscamos comenzar desde el w_min, lo que indicaria el punto mas cercano a la isosuperficie
        ssx = rx + [x0] + sx
        ssy = ry + [y0] + sy

        w_i = []
        for x, y in zip(ssx, ssy):
            w_i.append(self._interp_w(x, y).item())
        x_semilla = ssx[w_i.index(min(w_i))]
        y_semilla = ssy[w_i.index(min(w_i))]

        # Recalculamos streamlines desde las nuevas semillas
        sx, sy, ss, sz = self._makeHalfStreamline(x_semilla, y_semilla, xmin - dr, xmax + dr, ymin - dr, ymax + dr, dr, 1)  # forwards
        rx, ry, rs, rz = self._makeHalfStreamline(x_semilla, y_semilla, xmin - dr, xmax + dr, ymin - dr, ymax + dr, dr, -1)  # backwards

        rx.reverse()
        ry.reverse()
        rs.reverse()
        rz.reverse()

        return rx + [x_semilla] + sx, ry + [y_semilla] + sy, rs + [0.] + ss, rz + [0.] + sz, x_semilla, y_semilla

    def interpoladoresSZT(self, streamlines):

        nstream = len(streamlines[0][0])
        xs = []
        ys = []
        ss = []
        ts = []
        dzs = []
        # Definimos la coordenada t la cual es unica para cada linea de corriente
        tscale = np.sqrt((self.meshXmax - self.meshXmin) ** 2 + (self.meshYmax - self.meshYmin) ** 2) / nstream

        for enum, st in enumerate(streamlines):
            xs.extend(st[0])
            ys.extend(st[1])
            ss.extend(st[2])
            dzs.extend(st[3])
            ts.extend([enum * tscale] * len(st[0]))

        SG = griddata((xs, ys), ss, (self.XG, self.YG), method='cubic')
        TG = griddata((xs, ys), ts, (self.XG, self.YG), method='cubic')
        DZG = griddata((xs, ys), dzs, (self.XG, self.YG), method='cubic')

        self._interp_s = RectBivariateSpline(self.xg, self.yg, SG.T)
        self._interp_t = RectBivariateSpline(self.xg, self.yg, TG.T)
        self._interp_dz = RectBivariateSpline(self.xg, self.yg, DZG.T)

    def flujo_base_turbinas(self, lista_turbinas):

        for turbina in lista_turbinas:
            coord_xy = np.vstack(turbina.coord.x, turbina.coord.y)

            u = self._interp_u(*coord_xy).item()
            v = self._interp_v(*coord_xy).item()
            w = self._interp_w(*coord_xy).item()
            turbina.U = [u ,v ,w]

            turbina.t = self._interp_t(np.vstack(*coord_xy), grid=False).item()