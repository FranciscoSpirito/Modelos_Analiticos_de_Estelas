import numpy as np
from scipy.interpolate import griddata, RectBivariateSpline
from math import ceil

# Proyecto original: https://github.com/rougier/windmap

class Iso_Superficie(object):

    def __init__(self, X, Y, Z, U, V, W):
        """
        Compute a set of streamlines covering the given velocity field.
        X and Y - 1D or 2D (e.g. generated by np.meshgrid) arrays of the
                  grid points. The mesh spacing is assumed to be uniform
                  in each dimension.
        U and V - 2D arrays of the velocity field.
        """
        self.X = X
        self.Y = Y
        self.Z = Z
        self.U = U
        self.V = V
        self.W = W


    # Definicion de densidad y limites de grilla
    def new_grid(self, npois):
        npoiX, npoiY = npois, npois
        self.meshXmin, self.meshXmax = np.amin(self.X) + 0.1 * (np.amax(self.X) - np.amin(self.X)), np.amax(self.X) - 0.1 * (np.amax(self.X) - np.amin(self.X))
        self.meshYmin, self.meshYmax = np.amin(self.Y) + 0.1 * (np.amax(self.Y) - np.amin(self.Y)), np.amax(self.Y) - 0.1 * (np.amax(self.Y) - np.amin(self.Y))
        self.paso_grid = (self.meshXmax + self.meshXmin)/npois
        self.xg = np.linspace(self.meshXmin, self.meshXmax, npoiX)
        self.yg = np.linspace(self.meshYmin, self.meshYmax, npoiY)
        self.XG, self.YG = np.meshgrid(self.xg, self.yg)

        # Interpolaci√≥n de variables output de OF sobre la grilla regular
        self.ZG = griddata((self.X, self.Y), self.Z, (self.XG, self.YG), method='linear')
        self.UG = griddata((self.X, self.Y), self.U, (self.XG, self.YG), method='linear')
        self.VG = griddata((self.X, self.Y), self.V, (self.XG, self.YG), method='linear')
        self.WG = griddata((self.X, self.Y), self.W, (self.XG, self.YG), method='linear')

        # Definir interpoladores en base a la grilla regular
        self._interp_u = RectBivariateSpline(self.xg, self.yg, self.UG.T)
        self._interp_v = RectBivariateSpline(self.xg, self.yg, self.VG.T)
        self._interp_w = RectBivariateSpline(self.xg, self.yg, self.WG.T)
        self._interp_z = RectBivariateSpline(self.xg, self.yg, self.ZG.T)


    # Genera un streamline desde el punto x0 y0 hacia adelante o atras
    def _makeHalfStreamline(self, x0, y0, xmin, xmax, ymin, ymax, dr, s0, sign):
        """
        Compute a streamline extending in one direction from the given point.
        """

        sx = []
        sy = []
        ss = []
        sdz = []
        su = []
        sv = []
        sw = []

        x = x0
        y = y0
        s = s0
        dz = 0.

        sx.append(x)
        sy.append(y)
        sdz.append(dz)
        ss.append(s)


        while xmin <= x <= xmax and ymin <= y <= ymax:
            u = self._interp_u(x, y).item()
            v = self._interp_v(x, y).item()
            w = self._interp_w(x, y).item()

            scale = sign * (dr / np.sqrt(u ** 2 + v ** 2))
            scale2 = sign * (dr / np.sqrt(u ** 2 + v ** 2 + w**2))

            x += scale * u
            y += scale * v
            dz += scale2 * w
            s += np.sqrt(dr ** 2 + (scale2 * w) ** 2)

            sx.append(x)
            sy.append(y)
            sdz.append(dz)
            ss.append(s)
            su.append(u)
            sv.append(v)
            sw.append(w)

        return sx, sy, sdz, ss

    # Genera un streamline desde el punto x0 y0 hacia adelante y atras
    def _makeStreamline(self, x_semillas, y_semillas, dr, angulo):
        """
        Compute a streamline extending in both directions from the given point.
        """
        streamlines = []
        # Determinacion de s inicial de cada streamline
        for x0, y0 in zip(x_semillas, y_semillas):
            if angulo in [0, 90, 180, 270]:
                s0 = 0.
                t0 = abs((x_semillas[0] - x0) + (y_semillas[0] - y0))
            else:
                if y0 == y_semillas[0]:
                    s0 = (x_semillas[0]-x0) * np.cos(np.radians(90-angulo))
                    t0 = s0 * np.tan(np.radians(90-angulo))
                else:
                    s0 = (y_semillas[0] - y0) * np.cos(np.radians(angulo))
                    t0 = - s0 * np.tan(np.radians(angulo))

            xmin, xmax = self.meshXmin - 2*self.paso_grid, 2*self.meshXmax + 2*self.paso_grid
            ymin, ymax = self.meshYmin - 2*self.paso_grid, 2*self.meshYmax + 2*self.paso_grid

            sx, sy, sdz, ss = self._makeHalfStreamline(x0, y0, xmin, xmax, ymin, ymax, dr, s0, 1)  # forwards
            st = [t0] * len(sx)
            streamline = [sx, sy, ss, sdz, st]
            streamlines.append(streamline)

        return streamlines

    # Redefine interpoladores, luego de rotar las streamlines
    def redef_interpoladores(self, streamlines):

        nstream = len(streamlines)
        xs = []
        ys = []
        dzs = []
        ss = []
        ts = []

        for enum, st in enumerate(streamlines):
            xs.extend(st[0])
            ys.extend(st[1])
            ss.extend(st[2])
            dzs.extend(st[3])
            ts.extend(st[4])

        self.SG = griddata((xs, ys), ss, (self.XG, self.YG), method='cubic')
        self.TG = griddata((xs, ys), ts, (self.XG, self.YG), method='cubic')
        self.DZG = griddata((xs, ys), dzs, (self.XG, self.YG), method='cubic')

        self._interp_s = RectBivariateSpline(self.xg, self.yg, self.SG.T)
        self._interp_t = RectBivariateSpline(self.xg, self.yg, self.TG.T)
        self._interp_dz = RectBivariateSpline(self.xg, self.yg, self.DZG.T)


    def flujo_base_turbinas(self, lista_turbinas):

        for turbina in lista_turbinas:
            coord_xy = np.vstack((turbina.coord.x, turbina.coord.y))

            u = self._interp_u(*coord_xy).item()
            v = self._interp_v(*coord_xy).item()
            w = self._interp_w(*coord_xy).item()
            turbina.U_f_base = np.array([u ,v ,w])

            # turbina.t = self._interp_t(*coord_xy, grid=False).item()   # Este usabamos con RectBivariateSpline
            turbina.t = self._interp_t(*coord_xy).item()
            turbina.s = self._interp_s(*coord_xy).item()


    # Define la semilla inicial, debe cubrir todo el terreno
    def gen_semillas(self, angulo, nstream):

        b = self.meshXmax - self.meshXmin
        h = self.meshYmax - self.meshYmin
        dr = (np.sqrt(b**2 + h**2)) / nstream

        if angulo == 0:
            x_semilla = np.linspace(self.meshXmin, self.meshXmax, nstream)
            y_semilla = np.full(np.shape(x_semilla), self.meshYmax)
        elif angulo == 90:
            y_semilla = np.linspace(self.meshYmin, self.meshYmax, nstream)
            x_semilla = np.full(np.shape(y_semilla), self.meshXmax)
        elif angulo == 180:
            x_semilla = np.linspace(self.meshXmin, self.meshXmax, nstream)
            y_semilla = np.full(np.shape(x_semilla), self.meshYmin)
        elif angulo == 270:
            y_semilla = np.linspace(self.meshYmin, self.meshYmax, nstream)
            x_semilla = np.full(np.shape(y_semilla), self.meshXmin)
        elif angulo in [22.5, 45, 67.5]:
            angulo_rad = np.radians(angulo)
            nstream_x = int(ceil(abs(b / (dr / np.sin(np.pi / 2 - angulo_rad)))))
            nstream_y = int(ceil(abs(b / (dr / np.sin(angulo_rad)))))
            x_semilla = np.linspace(self.meshXmax, self.meshXmin, nstream_x)
            y_semilla = np.full(np.shape(x_semilla), self.meshYmax)
            y_semilla1 = np.linspace(self.meshYmax, self.meshYmin, nstream_y)
            x_semilla1 = np.full(np.shape(y_semilla1), self.meshXmax)
            x_semilla = np.append(x_semilla, x_semilla1)
            y_semilla = np.append(y_semilla, y_semilla1)
        elif angulo in [112.5, 135, 157.5]:
            angulo_rad = np.radians(angulo)
            nstream_x = int(ceil(abs(b / (dr / np.sin(np.pi / 2 - angulo_rad)))))
            nstream_y = int(ceil(abs(b / (dr / np.sin(angulo_rad)))))
            y_semilla = np.linspace(self.meshYmin, self.meshYmax, nstream_y)
            x_semilla = np.full(np.shape(y_semilla), self.meshXmax)
            x_semilla1 = np.linspace(self.meshXmax, self.meshXmin, nstream_x)
            y_semilla1 = np.full(np.shape(x_semilla1), self.meshYmin)
            x_semilla = np.append(x_semilla, x_semilla1)
            y_semilla = np.append(y_semilla, y_semilla1)
        elif angulo in [202.5, 225, 247.5]:
            angulo_rad = np.radians(angulo)
            nstream_x = int(ceil(abs(b / (dr / np.sin(np.pi / 2 - angulo_rad)))))
            nstream_y = int(ceil(abs(b / (dr / np.sin(angulo_rad)))))
            y_semilla = np.linspace(self.meshYmin, self.meshYmax, nstream_y)
            x_semilla = np.full(np.shape(y_semilla), self.meshXmin)
            x_semilla1 = np.linspace(self.meshXmin, self.meshXmax, nstream_x)
            y_semilla1 = np.full(np.shape(x_semilla1), self.meshYmin)
            x_semilla = np.append(x_semilla, x_semilla1)
            y_semilla = np.append(y_semilla, y_semilla1)
        else:
            angulo_rad = np.radians(angulo)
            nstream_x = int(ceil(abs(b / (dr / np.sin(np.pi / 2 - angulo_rad)))))
            nstream_y = int(ceil(abs(b / (dr / np.sin(angulo_rad)))))
            y_semilla = np.linspace(self.meshYmax, self.meshYmin, nstream_y)
            x_semilla= np.full(np.shape(y_semilla), self.meshXmin)
            x_semilla1 = np.linspace(self.meshXmin, self.meshXmax, nstream_x)
            y_semilla1 = np.full(np.shape(x_semilla1), self.meshYmax)
            x_semilla = np.append(x_semilla, x_semilla1)
            y_semilla = np.append(y_semilla, y_semilla1)

        return x_semilla, y_semilla

    # Rota las streamlines de modo que quede x sea la direccion del viento
    def rotar(self, angulo_viento, streamlines):
        theta = -(180 + (90 - angulo_viento))
        theta_rad = np.radians(theta)
        R = np.matrix([[np.cos(theta_rad), -np.sin(theta_rad)], [np.sin(theta_rad), np.cos(theta_rad)]])
        for streamline in streamlines:
            for i in range(len(streamline[0])):
                vector_coord = np.array([streamline[0][i], streamline[1][i]])
                vector_coord_rotado = np.dot(R, vector_coord)
                streamline[0][i] = vector_coord_rotado.getA1()[0]
                streamline[1][i] = vector_coord_rotado.getA1()[1]
                vector_vel = np.array([streamline[4][i], streamline[5][i]])
                vector_vel_rotado = np.dot(R, vector_vel)
                streamline[4][i] = vector_vel_rotado.getA1()[0]
                streamline[5][i] = vector_vel_rotado.getA1()[1]
        return streamlines



