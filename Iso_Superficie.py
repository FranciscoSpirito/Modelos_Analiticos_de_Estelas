import numpy as np
from scipy.interpolate import LinearNDInterpolator

class Iso_Superficie(object):


    def __init__(self, X, Y, Z, U, V, W):
        """
        Compute a set of streamlines covering the given velocity field.
        X and Y - 1D or 2D (e.g. generated by np.meshgrid) arrays of the
                  grid points. The mesh spacing is assumed to be uniform
                  in each dimension.
        U and V - 2D arrays of the velocity field.
        """


        xa = np.asanyarray(X)
        ya = np.asanyarray(Y)
        za = np.asanyarray(Z)
        self.x = xa
        self.y = ya
        self.z = za
        self.u = U
        self.v = V
        self.w = W
        self.dx = abs((self.x[-1] - self.x[0]) / (self.x.size - 1))  # assume a regular grid
        self.dy = abs((self.y[-1] - self.y[0]) / (self.y.size - 1))  # assume a regular grid
        self.dr = np.sqrt(self.dx**2 + self.dy**2)
        self.fill_value_u = np.mean(self.u)
        self.fill_value_v = np.mean(self.v)
        self.fill_value_w = np.mean(self.w)
        self.fill_value_z = np.mean(self.z)
        self._interp_u = LinearNDInterpolator(list(zip(self.x, self.y)), self.u, fill_value=self.fill_value_u)
        self._interp_v = LinearNDInterpolator(list(zip(self.x, self.y)), self.v, fill_value=self.fill_value_v)
        self._interp_w = LinearNDInterpolator(list(zip(self.x, self.y)), self.w, fill_value=self.fill_value_w)
        self._interp_z = LinearNDInterpolator(list(zip(self.x, self.y)), self.z, fill_value=self.fill_value_z)


    def streamline_in_coord(self, coord_turbina):
        streamline = self._makeHalfStreamline(coord_turbina.x, coord_turbina.y, 1)
        return streamline


    def _interp(self, x, y):
        """ Compute the velocity at point (x,y) """

        u = self._interp_u(x, y)
        v = self._interp_v(x, y)

        return u, v


    def _makeHalfStreamline(self, x0, y0, sign):
        """
        Compute a streamline extending in one direction from the given point.
        """

        xmin = np.amin(self.x)
        xmax = np.amax(self.x)
        ymin = np.amin(self.y)
        ymax = np.amax(self.y)

        sx = []
        sy = []

        x = x0
        y = y0

        while xmin < x < xmax and ymin < y < ymax:

            u, v = self._interp(x, y)

            x += sign * (self.dr / np.sqrt(u**2 + v**2)) * u
            y += sign * (self.dr / np.sqrt(u**2 + v**2)) * v

            sx.append(x)
            sy.append(y)


        return sx, sy

    def longitud_streamline(self, x, y):
        # Calcula la longitud de una curva 3d
        z = self._interp_z(x, y)
        return np.sum(np.sqrt(np.sum(np.diff([x, y, z]) ** 2, axis=0)))

    def desplazamiento_vertical(self, x, y):
        # Calcula el dezplazamiento vertical de la ldc con el metodo del trapezio con la coordenada curvilinea s
        z = self._interp_z(x, y)
        s_i = np.cumsum(np.sqrt(np.sum(np.diff([x, y, z]) ** 2, axis=0)))
        s_i = np.insert(s_i, 0, 0)
        f_uvw = self._interp_w(x, y) / (self._interp_u(x, y) ** 2 + self._interp_v(x, y) ** 2)
        dz = np.trapz(f_uvw, x = s_i)
        return dz


