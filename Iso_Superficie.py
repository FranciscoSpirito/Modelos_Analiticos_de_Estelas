import numpy as np
from scipy.interpolate import griddata, RectBivariateSpline

class Iso_Superficie(object):

    def __init__(self, X, Y, Z, U, V, W, npois):
        """
        Compute a set of streamlines covering the given velocity field.
        X and Y - 1D or 2D (e.g. generated by np.meshgrid) arrays of the
                  grid points. The mesh spacing is assumed to be uniform
                  in each dimension.
        U and V - 2D arrays of the velocity field.
        """

        self.x = X
        self.y = Y
        self.z = Z
        self.u = U
        self.v = V
        self.w = W

        # Definicion de densidad y limites de grilla
        npoiX, npoiY = npois, npois
        meshXmin, meshXmax = 1000, 5500
        meshYmin, meshYmax = 500, 5000
        xg = np.linspace(meshXmin, meshXmax, npoiX)
        yg = np.linspace(meshYmin, meshYmax, npoiY)
        XG, YG = np.meshgrid(xg, yg)

        # Interpolaci√≥n de variables output de OF sobre la grilla regular
        self.ZG = griddata((self.x, self.y), self.z, (XG, YG), method='linear')
        self.UG = griddata((self.x, self.y), self.u, (XG, YG), method='linear')
        self.VG = griddata((self.x, self.y), self.v, (XG, YG), method='linear')
        self.WG = griddata((self.x, self.y), self.w, (XG, YG), method='linear')

        # Definir interpoladores en base a la grilla regular
        self._interp_u = RectBivariateSpline(xg, yg, self.UG.T)
        self._interp_v = RectBivariateSpline(xg, yg, self.VG.T)
        self._interp_w = RectBivariateSpline(xg, yg, self.WG.T)
        self._interp_z = RectBivariateSpline(xg, yg, self.ZG.T)


    # Genera un streamline desde el punto x0 y0 hacia adelante o atras
    def _makeHalfStreamline(x0, y0, xmin, xmax, ymin, ymax, dr, sign):
        """
        Compute a streamline extending in one direction from the given point.
        """

        sx = []
        sy = []
        sz = []

        x = x0
        y = y0
        dz = 0.

        while xmin <= x <= xmax and ymin <= y <= ymax:
            u = self._interp_u(x, y).item()
            v = self._interp_v(x, y).item()
            w = self._interp_w(x, y).item()

            scale = sign * (dr / np.sqrt(u ** 2 + v ** 2 + w ** 2))

            x += scale * u
            y += scale * v
            dz += scale * w
            z = self._interp_z(x, y).item() + dz

            sx.append(x)
            sy.append(y)
            sz.append(z)

        return sx, sy, sz

    def _makeStreamline(x0, y0, xmin, xmax, ymin, ymax, dr):
        """
        Compute a streamline extending in both directions from the given point.
        """

        sx, sy, sz = _makeHalfStreamline(x0, y0, xmin, xmax, ymin, ymax, dr, 1)  # forwards
        rx, ry, rz = _makeHalfStreamline(x0, y0, xmin, xmax, ymin, ymax, dr, -1)  # backwards

        rx.reverse()
        ry.reverse()
        rz.reverse()

        # Busqueda de Semilla para corregir desplazamiento en z, buscamos comenzar desde el w_min, lo que indicaria el punto mas cercano a la isosuperficie
        ssx = rx + [x0] + sx
        ssy = ry + [y0] + sy

        w_i = []
        for x, y in zip(ssx, ssy):
            w_i.append(self._interp_w(x, y).item())
        x_semilla = ssx[w_i.index(min(w_i))]
        y_semilla = ssy[w_i.index(min(w_i))]
        #     x_semilla = x0
        #     y_semilla = y0

        sx, sy, sz = _makeHalfStreamline(x_semilla, y_semilla, xmin - dr, xmax + dr, ymin - dr, ymax + dr, dr,
                                         1)  # forwards
        rx, ry, rz = _makeHalfStreamline(x_semilla, y_semilla, xmin - dr, xmax + dr, ymin - dr, ymax + dr, dr,
                                         -1)  # backwards

        rx.reverse()
        ry.reverse()
        rz.reverse()

        return rx + [x_semilla] + sx, ry + [y_semilla] + sy, rz + [
            self._interp_z(x_semilla, y_semilla).item()] + sz, x_semilla, y_semilla

